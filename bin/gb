#!/usr/bin/env ruby  -rubygems
#Executes with rubygems by default.  This way there is a singular place to change the package management system if you are not using rubygems.  

require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'gradebook'

# require 'gdata_gradebook'



options = {}

opt_parser = OptionParser.new do |opt|
    opt.program_name="Gradebook App"
    
  opt.banner = "Usage: opt_parser COMMAND [OPTIONS]"
  opt.separator ""
  opt.separator "Commands"
	opt.separator "Version b"
  opt.separator " search --lastname babbage"
  opt.separator " search --firstname chuck"
  opt.separator " grade all"
  opt.separator " grade --sid 1010"
  opt.separator "report --sid 1010"
  opt.separator "report --sid 1010 --out xml"
  opt.separator "report --lastname babbage"
  opt.separator "report --lastname babbage --out xml"
  opt.separator "To work with a different spreadsheet id"
  opt.separator "new_class"
	opt.separator "To clear credentials"
	opt.separator "clear_credentials"
  
  opt.on("-c CREATE","--create CREATE ") do |course|
    options[:course] = course
  end
  
  opt.on("-u UPLOADROSTER","--uploadroster UPLOADROSTER") do |roster|
      options[:roster]=roster
  end
  
  opt.on("-e ENVIRONMENT", "--environement ENVIRONEMENT") do |environement|
      option[:environment]=environment
  end
  
  opt.on("-d","--daemon","runing on daemon mode?") do
    options[:daemon] = true
  end
  
  opt.on("-h","--help","help") do
    puts opt_parser
  end
  
  opt.on("--course COURSE") do |course|
      options[:course]=course
  end
  
  opt.on("--range RANGE") do |range|
      options[:range]=range
  end
  
  opt.on("--sid SID") do |sid|
      options[:sid]=sid
  end
  
  opt.on("--name NAME") do |name|
	options[:name]=name
  end
  
  opt.on("--firstname NAME") do |name|
      options[:firstname]=name
  end
  
  opt.on("--lastname NAME") do |name|
      options[:lastname]=name
  end

  opt.on("--out OUT") do |out|
      options[:out]=out
  end

end

opt_parser.parse!


case ARGV[0]

when "authenticate"
  puts "Authenticate with #{options.inspect}"
  client=Gradebook::Client.new
    # puts "Enter Google Account"
    # username=STDIN.gets()
    # puts "Enter Google Password"
    # `stty -echo`
    # print "Password: "
    # password = STDIN.gets.chomp
    # `stty echo`
    # puts ""
    username=""
    password=""
    @clients=client.setup(username,password)
    @doc_client=@clients[0]
    @spradesheet_client=@clients[1]
    
    client.get
   # client.post2
#    client.post
when "create"

    puts "Creating Gradebook #{options[:course]}"
            client=Gradebook::Client.new
            @clients=client.setup("","")
            @doc_client=@clients[0]
            @spradesheet_client=@clients[1]

    if @doc_client==nil
        raise "Authentication Failer"
    end
    book=Gradebook::Book.new
    book.create(@doc_client,options[:course])
    
    # rescue 
    #     raise "User must authenticate. \n 
    #     try >>grade authenticate"
    # end

when "uploadroster"
    puts "Uploading Roster"
    client=Gradebook::Client.new
    @clients=client.setup("","")
    @doc_client=@clients[0]
    @spradesheet_client=@clients[1]
    
    book=Gradebook::Book.new
    roster=File.open(options[:roster])
    book.create(@doc_client,"testupload")
    book.import_roster(@doc_client,@spradesheet_client,roster)
    
when "getcourse"
    client=Gradebook::Client.new
    client.setup("","")
    client.get_course(options[:course])

# ./bin/gb grade --range A/all or --range SID     
when "grade"
    if ARGV[1]!="all" 
        user_grades=Gradebook::Usergrades.new
        option=options[:sid]
		puts "test"
        user_grades.grade_by_sid(option)
    else
        user_grades=Gradebook::Usergrades.new
        user_grades.grade_all
    end
    

when "report"

    user_grades=Gradebook::Usergrades.new
    if options[:sid]
        sid=options[:sid]
        if options[:out]=="xml"
            user_grades.grade_report_xml(sid)
        else
            user_grades.grade_report(sid)
        end
=begin
	TODO CHANGE NAME TO FIRST AND LAST 
=end
    elsif options[:firstname]
        name=options[:firstname]
        if options[:out]=="xml"
           user_grades.grade_report_by_name_xml("firstname",name) 
        else
            user_grades.grade_report_by_name("firstname",name)
        end
	elsif options[:lastname]
		name=options[:lastname]
		if options[:out]=="xml"
           user_grades.grade_report_by_name_xml("lastname",name) 
        else
            user_grades.grade_report_by_name("lastname",name)
        end
    end
    


when "search"
	column='', name=''
	if options[:firstname]!=nil
		column="firstname"
		name=options[:firstname]
	end
	
	if options[:lastname]!=nil
		column="lastname"
		name=options[:lastname]
	end

    @client=Gradebook::Client.new
	@function=Gradebook::Utility::Function.new(@client)
    sids=@function.search_for_and_return_sid(column,name)
    puts "Searching for student... #{name}"
	puts "Matches"
	sids.each do |key,value|
		puts "Name: #{value}.... #{key}"
	end


when "category"
    if ARGV[1]=="new"
        if options[:name]!=nil
            category_name=options[:name]
            user_grades=Gradebook::Usergrades.new
            user_grades.new_category(category_name)
        else
            puts "No name for a new category given \n \e[1;37mcategory new --name CategoryName\e[0m"
        end
    elsif ARGV[1]=="remove"
        if options[:name]!=nil
            category_name=options[:name]
            user_grades=Gradebook::Usergrades.new
            user_grades.remove_category(category_name)
        else
            puts "No name for a new category given \n \e[1;37mcategory remove --name CategoryName\e[0m"
        end
    end
         

when "load"

    x='a'

#    x=STDIN.gets.chomp()
  
when "new_class"
	@client=Gradebook::Client.new
	@client.clear_sps_id

when "clear_credentials"
	@client=Gradebook::Client.new
	@client.clear_credentials

when "setup"
	
when "quit"
	exit
else
  puts opt_parser
end




    


